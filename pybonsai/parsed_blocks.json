[
  {
    "type": "docstring",
    "line_number": 0,
    "signature": "",
    "indent_level": 0,
    "docstring": [
      "\"\"\"",
      "This file is part of the \"NECBOL Plain Language Python NEC Runner\"",
      "Copyright (c) 2025 Alan Robinson G1OJS",
      "",
      "MIT License",
      "",
      "Permission is hereby granted, free of charge, to any person obtaining a copy",
      "of this software and associated documentation files (the \"Software\"), to deal",
      "in the Software without restriction, including without limitation the rights",
      "to use, copy, modify, merge, publish, distribute, sublicense, and/or sell",
      "copies of the Software, and to permit persons to whom the Software is",
      "furnished to do so, subject to the following conditions:",
      "",
      "The above copyright notice and this permission notice shall be included in all",
      "copies or substantial portions of the Software.",
      "",
      "THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR",
      "IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,",
      "FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE",
      "AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER",
      "LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,",
      "OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE",
      "SOFTWARE.",
      "\"\"\""
    ],
    "body": [
      "",
      "import numpy as np",
      "import math",
      "import warnings",
      "import subprocess",
      "import os",
      "import time",
      "",
      "#=================================================================================",
      "# NEC Wrapper functions for writing .nec file and reading output",
      "#================================================================================="
    ]
  },
  {
    "type": "class",
    "line_number": 36,
    "signature": "NECModel:",
    "indent_level": 0,
    "docstring": [],
    "body": []
  },
  {
    "type": "def",
    "line_number": 37,
    "signature": "__init__(self, working_dir, nec_exe_path, model_name = \"Unnamed_Antennna\", verbose=False)",
    "indent_level": 1,
    "docstring": [],
    "body": [
      "        self.verbose = verbose",
      "        self.working_dir = working_dir",
      "        self.nec_exe = nec_exe_path",
      "        self.nec_bat = working_dir + \"\\\\nec.bat\"",
      "        self.nec_in = working_dir + \"\\\\\" + model_name +  \".nec\"",
      "        self.nec_out = working_dir + \"\\\\\" + model_name +  \".out\"",
      "        self.files_txt = working_dir + \"\\\\files.txt\"",
      "        self.model_name = model_name",
      "        self.nSegs_per_wavelength = 40",
      "        self.segLength_m = 0",
      "        self._units = _units()",
      "        self.default_wire_sigma = None",
      "        self.MHz = None",
      "        self.MHz_stop = None",
      "        self.MHz_step = None",
      "        self.origin_height_m = 0",
      "        self.segLength_m",
      "        self.el_datum_deg = 0",
      "        self.az_datum_deg = 0",
      "        self.az_step_deg = 10",
      "        self.el_step_deg = 5",
      "        self.ground_sigma = 0",
      "        self.ground_Er = 1.0",
      "        self.geometry = []",
      "        self.EX_tag = 999",
      "        self.LOADS = []",
      "        self.LOADS_start_tag = 8000",
      "        self.max_total_gain = None",
      "        self.vswr = None",
      "        self.tags_info = []"
    ]
  },
  {
    "type": "def",
    "line_number": 69,
    "signature": "set_name(self, name)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Set the name of the model. This is used in NEC input file generation and is reflected in the NEC",
      "            output file name. It is permissible to use this function to re-set the name after a NEC run has completed,",
      "            so that the analysis continues (with updated input parameters) and outputs more than one test case",
      "        \"\"\""
    ],
    "body": [
      "        self.model_name = name",
      "        self.nec_in = self.working_dir + \"\\\\\" + self.model_name +  \".nec\"",
      "        self.nec_out = self.working_dir + \"\\\\\" + self.model_name +  \".out\"",
      "        self._write_runner_files()"
    ]
  },
  {
    "type": "def",
    "line_number": 80,
    "signature": "set_wire_conductivity(self, sigma)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Set wire conductivity to be assumed for all wires that don't have an explicitly-set load.",
      "        \"\"\""
    ],
    "body": [
      "        self.default_wire_sigma = sigma",
      "        self.LOADS.append({'iTag': 0, 'load_type': 'conductivity', 'RoLuCp': (sigma, 0, 0), 'alpha': None})"
    ]
  },
  {
    "type": "def",
    "line_number": 87,
    "signature": "set_frequency(self, MHz)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Request NEC to perform all analysis at the specified frequency. ",
      "        \"\"\""
    ],
    "body": [
      "        self.MHz = MHz",
      "        lambda_m = 300/MHz",
      "        self.segLength_m = lambda_m / self.nSegs_per_wavelength"
    ]
  },
  {
    "type": "def",
    "line_number": 95,
    "signature": "set_gain_point(self, azimuth_deg, elevation_deg)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Set the azimuth and elevation of a single gain point that",
      "            must appear in the output radiation pattern",
      "        \"\"\""
    ],
    "body": [
      "        self.az_datum_deg = azimuth_deg",
      "        self.el_datum_deg = elevation_deg",
      ""
    ]
  },
  {
    "type": "def",
    "line_number": 104,
    "signature": "set_angular_resolution(self, az_step_deg, el_step_deg)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Set resolution required in az and el in degrees",
      "            If a ground is specified, NEC will be asked for a hemisphere, otherwise a sphere",
      "        \"\"\""
    ],
    "body": [
      "        self.az_step_deg = az_step_deg",
      "        self.el_step_deg = el_step_deg"
    ]
  },
  {
    "type": "def",
    "line_number": 112,
    "signature": "set_ground(self, eps_r, sigma, **origin_height)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Sets the ground relative permitivity and conductivity. Currently limited to simple choices.",
      "            If eps_r = 1, nec is told to use no ground (free space model), and you may omit the origin height parameter",
      "            If you don't call this function, free space will be assumed.",
      "            Othewise you should set the origin height so that the antenna reference point X,Y,Z = (0,0,0) is set to be",
      "            the specified distance above ground.",
      "            Parameters:",
      "                eps_r (float): relative permittivity (relative dielectric constant) of the ground",
      "                sigma (float): conductivity of the ground in mhos/meter",
      "                origin_height_{units_string} (float): Height of antenna reference point X,Y,Z = (0,0,0)",
      "        \"\"\""
    ],
    "body": [
      "        self.ground_Er = eps_r",
      "        self.ground_sigma = sigma",
      "        if(eps_r >1.0):",
      "            self.origin_height_m = self._units._from_suffixed_dimensions(origin_height)['origin_height_m']",
      "            if(self.el_datum_deg <= 0):",
      "                self.el_datum_deg = 1"
    ]
  },
  {
    "type": "def",
    "line_number": 131,
    "signature": "place_RLC_load(self, geomObj, R_Ohms, L_uH, C_pf, load_type = 'series', load_alpha_object=-1, load_wire_index=-1, load_alpha_wire=-1)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            inserts a single segment containing an RLC load into an existing geometry object",
      "            Position within the object is specied as",
      "            EITHER:",
      "              load_alpha_object (range 0 to 1) as a parameter specifying the length of",
      "                                wire traversed to reach the item by following each wire in the object,",
      "                                divided by the length of all wires in the object",
      "                                (This is intended to be used for objects like circular loops where there",
      "                                are many short wires each of the same length)",
      "            OR:",
      "              load_wire_index AND load_alpha_wire",
      "              which specify the i'th wire (0 to n-1) in the n wires in the object, and the distance along that",
      "              wire divided by that wire's length",
      "",
      "            NEC LD card specification: https://www.nec2.org/part_3/cards/ld.html",
      "        \"\"\""
    ],
    "body": [
      "",
      "        iTag = self.LOADS_start_tag + len(self.LOADS)",
      "        self.LOADS.append({'iTag': iTag, 'load_type': load_type, 'RoLuCp': (R_Ohms, L_uH, C_pf), 'alpha': None})",
      "        self._insert_special_segment(geomObj, iTag, load_alpha_object, load_wire_index, load_alpha_wire)"
    ]
  },
  {
    "type": "def",
    "line_number": 153,
    "signature": "place_feed(self,  geomObj, feed_alpha_object=-1, feed_wire_index=-1, feed_alpha_wire=-1)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Inserts a single segment containing the excitation point into an existing geometry object.",
      "            Position within the object is specied as",
      "            EITHER:",
      "              feed_alpha_object (range 0 to 1) as a parameter specifying the length of",
      "                                wire traversed to reach the item by following each wire in the object,",
      "                                divided by the length of all wires in the object",
      "                                (This is intended to be used for objects like circular loops where there",
      "                                are many short wires each of the same length)",
      "            OR:",
      "              feed_wire_index AND feed_alpha_wire",
      "              which specify the i'th wire (0 to n-1) in the n wires in the object, and the distance along that",
      "              wire divided by that wire's length",
      "        \"\"\""
    ],
    "body": [
      "        self._insert_special_segment(geomObj, self.EX_tag, feed_alpha_object, feed_wire_index, feed_alpha_wire)"
    ]
  },
  {
    "type": "def",
    "line_number": 170,
    "signature": "add(self, geomObj, wireframe_color = 'darkgoldenrod')",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Add a completed component to the specified model: model_name.add(component_name). Any changes made",
      "            to the component after this point are ignored.",
      "        \"\"\""
    ],
    "body": [
      "        geomObj.wireframe_color = wireframe_color",
      "        self.tags_info.append({'base_tag':geomObj.base_tag,'wf_col':geomObj.wireframe_color})",
      "        self.geometry.append(geomObj)"
    ]
  },
  {
    "type": "def",
    "line_number": 179,
    "signature": "write_nec(self)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Write the entire model to the NEC input file ready for analysis. At this point, the function",
      "            \"show_wires_from_file\" may be used to see the specified geometry in a 3D view.",
      "        \"\"\""
    ],
    "body": [
      "        print(\"Writing NEC input file\")",
      "        self._write_runner_files()",
      "        ",
      "        # open the .nec file",
      "        with open(self.nec_in, \"w\") as f:",
      "            f.write(\"CM\\nCE\\n\")",
      "            ",
      "            # Write GW lines for all geometry",
      "            for geomObj in self.geometry:",
      "                for w in geomObj._get_wires():",
      "                    #print(f\"Write wire with tag {w['iTag']}\")",
      "                    A = np.array(w[\"a\"], dtype=float)",
      "                    B = np.array(w[\"b\"], dtype=float)",
      "                    if(w['nS'] == 0): # calculate and update number of segments only if not already present",
      "                        w['nS'] = 1+int(np.linalg.norm(B-A) / self.segLength_m)",
      "                    f.write(f\"GW {w['iTag']} {w['nS']} \")",
      "                    f.write(' '.join([f\"{A[i]:.3f} \" for i in range(3)]))",
      "                    f.write(' '.join([f\"{B[i]:.3f} \" for i in range(3)]))",
      "                    f.write(f\" {w['wr']}\\n\")",
      "",
      "            # Write GE card, Ground Card, and GM card to set origin height",
      "            if self.ground_Er == 1.0:",
      "                f.write(\"GE 0\\n\")",
      "            else:",
      "                f.write(f\"GM 0 0 0 0 0 0 0 {self.origin_height_m:.3f}\\n\")",
      "                f.write(\"GE -1\\n\")",
      "                f.write(f\"GN 2 0 0 0 {self.ground_Er:.3f} {self.ground_sigma:.3f} \\n\")",
      "            ",
      "            # Write EK card",
      "            f.write(\"EK\\n\")",
      "",
      "            # Write out the loads",
      "            for LD in self.LOADS:",
      "                LDTYP = ['series','parallel','series_per_metre','parallel_per_metre','impedance_not_used','conductivity'].index(LD['load_type'])",
      "                LDTAG = LD['iTag']",
      "                R_Ohms, L_uH , C_pF = LD['RoLuCp']",
      "                # these strings are set programatically so shouldn't need an error trap",
      "                f.write(f\"LD {LDTYP} {LDTAG} 0 0 {R_Ohms:8.4e} {L_uH * 1e-6:8.4e} {C_pF * 1e-12:8.4e}\\n\")",
      "",
      "            # Feed",
      "            f.write(f\"EX 0 {self.EX_tag} 1 0 1 0\\n\")",
      "",
      "            # Frequency",
      "            # update to include sweep",
      "            f.write(f\"FR 0 1 0 0 {self.MHz:.3f} 0\\n\")",
      "",
      "            # Pattern points",
      "            n_phi = 1 + int(360 / self.az_step_deg)",
      "            d_phi = 360 / (n_phi - 1)",
      "            phi_start_deg = self.az_datum_deg",
      "            if self.ground_Er == 1.0:  # free space, no ground card, full sphere is appropriate",
      "                theta_start_deg, d_theta, n_theta = self._set_theta_grid_from_el_datum(self.el_datum_deg, self.el_step_deg, hemisphere = False)",
      "                f.write(f\"RP 0 {n_theta} {n_phi} 1003 {theta_start_deg} {phi_start_deg} {d_theta} {d_phi}\\n\")",
      "            else:                       # ground exists, upper hemisphere is appropriate",
      "                theta_start_deg, d_theta, n_theta = self._set_theta_grid_from_el_datum(self.el_datum_deg, self.el_step_deg, hemisphere = True)",
      "                f.write(f\"RP 0 {n_theta} {n_phi} 1003 {theta_start_deg} {phi_start_deg} {d_theta} {d_phi}\\n\")",
      "                ",
      "            f.write(\"EN\")"
    ]
  },
  {
    "type": "def",
    "line_number": 243,
    "signature": "run_nec(self)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "        Pass the model file to NEC for analysis and wait for the output.",
      "        \"\"\""
    ],
    "body": [
      "        try:",
      "            os.remove(self.nec_out)",
      "        except FileNotFoundError:",
      "            pass",
      "",
      "        print(\"Running NEC\")",
      "        subprocess.Popen([self.nec_bat], creationflags=subprocess.CREATE_NO_WINDOW)",
      "",
      "        factored = False",
      "        pattern_started = False",
      "        st = time.time()",
      "",
      "        while True:",
      "            try:",
      "                with open(self.nec_out, \"r\") as f:",
      "                    lines = f.readlines()",
      "                    for line in lines:",
      "                        if \"FACTOR=\" in line and not factored:",
      "                            factored = True",
      "                            print(\"Matrix factored\")",
      "                        if \"RADIATION\" in line and not pattern_started:",
      "                            pattern_started = True",
      "                            print(\"Calculating pattern\")",
      "                        if \"ERROR\" in line:",
      "                            raise Exception(f\"NEC Error: {line.strip()}\")",
      "                        if \"RUN\" in line:",
      "                            print(\"NEC run completed\")",
      "                            return  # success",
      "            except FileNotFoundError:",
      "                pass  # Output not yet created",
      "                if time.time() - st > 10:",
      "                    raise Exception(\"Timeout waiting for NEC to start\")",
      "",
      "            time.sleep(0.5)",
      "",
      "",
      "#===============================================================",
      "# internal functions for class NECModel",
      "#==============================================================="
    ]
  },
  {
    "type": "def",
    "line_number": 287,
    "signature": "_set_frequency_sweep(self, MHz, MHz_stop, MHz_step)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Set parameters for frequency sweep. This also sets the angular pattern resolution",
      "            to 10 degrees in azimuth and elevation to limit the size of output files           ",
      "        \"\"\""
    ],
    "body": [
      "        self.MHz_stop = MHz_stop",
      "        self.MHz_step = MHz_step",
      "        self.MHz = MHz",
      "        lambda_m = 300/MHz_stop",
      "        self.segLength_m = lambda_m / self.nSegs_per_wavelength",
      "        self.set_angular_resolution(10,10)",
      ""
    ]
  },
  {
    "type": "def",
    "line_number": 300,
    "signature": "_set_theta_grid_from_el_datum(self, el_datum_deg, el_step_deg, hemisphere = True)",
    "indent_level": 1,
    "docstring": [],
    "body": [
      "        theta_datum = 90 - el_datum_deg",
      "        d_theta = el_step_deg",
      "        theta_range = 90 if hemisphere else 180",
      "",
      "        theta_start = theta_datum % d_theta",
      "        # Fix float errors (e.g. 0.0000001)",
      "        theta_start = round(theta_start, 6)",
      "",
      "        # Clip to max range",
      "        max_theta = theta_start + d_theta * (int((theta_range - theta_start) / d_theta))",
      "        n_theta = 1 + int((max_theta - theta_start) / d_theta)",
      "        return theta_start, d_theta, n_theta"
    ]
  },
  {
    "type": "def",
    "line_number": 314,
    "signature": "_write_runner_files(self)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Write the .bat file to start NEC, and 'files.txt' to tell NEC the name of the input and output files",
      "        \"\"\""
    ],
    "body": [
      "        for filepath, content in [",
      "            (self.nec_bat, f\"{self.nec_exe} < {self.files_txt} \\n\"),",
      "            (self.files_txt, f\"{self.nec_in}\\n{self.nec_out}\\n\")",
      "        ]:",
      "            directory = os.path.dirname(filepath)",
      "            if directory and not os.path.exists(directory):",
      "                os.makedirs(directory)  # create directory if it doesn't exist",
      "            try:",
      "                with open(filepath, \"w\") as f:",
      "                    f.write(content)",
      "            except Exception as e:",
      "                print(f\"Error writing file {filepath}: {e}\")"
    ]
  },
  {
    "type": "def",
    "line_number": 331,
    "signature": "_insert_special_segment(self, geomObj, item_iTag, item_alpha_object, item_wire_index, item_alpha_wire)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            inserts a single segment with a specified iTag into an existing geometry object",
      "            position within the object is specied as either item_alpha_object or item_wire_index, item_alpha_wire",
      "            (see calling functions for more details)",
      "        \"\"\""
    ],
    "body": [
      "        wires = geomObj._get_wires()",
      "        if(item_alpha_object >=0):",
      "            item_wire_index = min(len(wires)-1,int(item_alpha_object*len(wires))) # 0 to nWires -1",
      "            item_alpha_wire = item_alpha_object - item_wire_index",
      "        w = wires[item_wire_index]       ",
      "",
      "        # calculate wire length vector AB, length a to b and distance from a to feed point",
      "        A = np.array(w[\"a\"], dtype=float)",
      "        B = np.array(w[\"b\"], dtype=float)",
      "        AB = B-A",
      "        wLen = np.linalg.norm(AB)",
      "        feedDist = wLen * item_alpha_wire",
      "",
      "        if (wLen <= self.segLength_m):",
      "            # feed segment is all of this wire, so no need to split",
      "            # print(f\"Change wire itag from {w['iTag']} to {item_iTag}\")",
      "            w['nS'] = 1",
      "            w['iTag'] = item_iTag",
      "        else:",
      "            # split the wire AB into three wires: A to C, CD (feed segment), D to B",
      "            nS1 = int(feedDist / self.segLength_m)              # no need for min of 1 as we always have the feed segment",
      "            C = A + AB * (nS1 * self.segLength_m) / wLen        # feed segment end a",
      "            D = A + AB * ((nS1+1) * self.segLength_m) / wLen    # feed segment end b",
      "            nS2 = int((wLen-feedDist) / self.segLength_m)       # no need for min of 1 as we always have the feed segment",
      "            # write results back to geomObj: modify existing wire to end at C, add feed segment CD and final wire DB",
      "            # (nonzero nS field is preserved during segmentation in 'add')",
      "            w['b'] = tuple(C)",
      "            w['nS'] = nS1",
      "            geomObj._add_wire(item_iTag , 1, *C, *D, w[\"wr\"])",
      "            geomObj._add_wire(w[\"iTag\"] , nS2, *D, *B, w[\"wr\"])",
      "            ",
      "",
      "#=================================================================================",
      "# The geometry object that holds a single component plus its methods",
      "#================================================================================="
    ]
  },
  {
    "type": "class",
    "line_number": 373,
    "signature": "GeometryObject:",
    "indent_level": 0,
    "docstring": [],
    "body": []
  },
  {
    "type": "def",
    "line_number": 374,
    "signature": "__init__(self, wires)",
    "indent_level": 1,
    "docstring": [],
    "body": [
      "        self.wires = wires  # list of wire dicts with iTag, nS, x1, y1, ...",
      "        self._units = _units()",
      "        self.wireframe_color = None"
    ]
  },
  {
    "type": "def",
    "line_number": 379,
    "signature": "translate(self, **params)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Translate an object by dx, dy, dz",
      "            Arguments are dx_{units}, dy_{units}, dz_{units}",
      "        \"\"\""
    ],
    "body": [
      "        params_m = self._units._from_suffixed_dimensions(params)",
      "        for w in self.wires:",
      "            w['a'] = tuple(map(float,np.array(w['a']) + np.array([params_m.get('dx_m'), params_m.get('dy_m'), params_m.get('dz_m')])))",
      "            w['b'] = tuple(map(float,np.array(w['b']) + np.array([params_m.get('dx_m'), params_m.get('dy_m'), params_m.get('dz_m')])))"
    ]
  },
  {
    "type": "def",
    "line_number": 389,
    "signature": "rotate_ZtoY(self)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Rotate the object through 90 degrees around X",
      "        \"\"\""
    ],
    "body": [
      "        R = np.array([[1, 0, 0],[0,  0, 1],[0,  -1, 0]])",
      "        return self._rotate(R)"
    ]
  },
  {
    "type": "def",
    "line_number": 396,
    "signature": "rotate_ZtoX(self)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Rotate the object through 90 degrees around Y",
      "        \"\"\""
    ],
    "body": [
      "        R = np.array([[0, 0, 1],[0,  1, 0],[-1,  0, 0]])",
      "        return self._rotate(R)"
    ]
  },
  {
    "type": "def",
    "line_number": 403,
    "signature": "rotate_around_X(self, angle_deg)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Rotate the object through angle_deg degrees around X",
      "        \"\"\""
    ],
    "body": [
      "        ca, sa = self._cos_sin(angle_deg)",
      "        R = np.array([[1, 0, 0],",
      "                      [0, ca, -sa],",
      "                      [0, sa, ca]])",
      "        return self._rotate(R)"
    ]
  },
  {
    "type": "def",
    "line_number": 413,
    "signature": "rotate_around_Y(self, angle_deg)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Rotate the object through angle_deg degrees around Y",
      "        \"\"\""
    ],
    "body": [
      "        ca, sa = self._cos_sin(angle_deg)",
      "        R = np.array([[ca, 0, sa],",
      "                      [0, 1, 0],",
      "                      [-sa, 0, ca]])",
      "        return self._rotate(R)"
    ]
  },
  {
    "type": "def",
    "line_number": 423,
    "signature": "rotate_around_Z(self, angle_deg)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Rotate the object through angle_deg degrees around Z",
      "        \"\"\""
    ],
    "body": [
      "        ca, sa = self._cos_sin(angle_deg)",
      "        R = np.array([[ca, -sa, 0],",
      "                      [sa, ca, 0],",
      "                      [0, 0, 1]])",
      "        return self._rotate(R)"
    ]
  },
  {
    "type": "def",
    "line_number": 433,
    "signature": "connect_ends(self, other, tol=1e-3, verbose = False)",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"",
      "            Check both ends of the wire to see if they lie on any wires in the specified object,",
      "            and if so, split the wires of the specified object so that NEC considers them to be",
      "            a valid T junction. Usage is:",
      "",
      "            wire.connect_ends(object, [tol in m], [verbose])",
      "",
      "            if verbose is True, details of the wire connection(s) are printed",
      "        \"\"\""
    ],
    "body": [
      "        wires_to_add=[]",
      "        for ws in self.wires:",
      "            if(verbose):",
      "                print(f\"\\nChecking if ends of wire from {ws['a']} to {ws['b']} should connect to any of {len(other.wires)} other wires:\")",
      "            for es in [ws[\"a\"], ws[\"b\"]]:",
      "                for wo in other.wires:",
      "                    if (self._point_should_connect_to_wire(es,wo,tol)):",
      "                        wire_seg_status = f\"{wo['nS']} segment\" if wo['nS'] > 0 else 'unsegmented'",
      "                        length_orig = np.linalg.norm(np.array(wo[\"a\"]) - np.array(wo[\"b\"]))",
      "                        b_orig = wo[\"b\"]",
      "                        wo['b']=tuple(es)",
      "                        length_shortened = np.linalg.norm(np.array(wo[\"a\"]) - np.array(wo[\"b\"]))",
      "                        nS_shortened = max(1, int(wo['nS']*length_shortened/length_orig))",
      "                        nS_orig = wo['nS']",
      "                        wo['nS'] = nS_shortened",
      "                        nS_remainder = max(1,nS_orig - nS_shortened)",
      "                        wires_to_add.append( (wo['iTag'], nS_remainder, *wo['b'], *b_orig, wo['wr']) )",
      "                        length_remainder = np.linalg.norm(np.array(wo[\"b\"]) - np.array(b_orig))",
      "                        if(verbose):",
      "                            print(f\"Inserting end of wire at {wo['b']} into {wire_seg_status} wire {length_orig}m wire from {wo['a']} to {b_orig}:\")",
      "                            print(f\"    by shortening wire to end at {wo['b']}: {length_shortened}m, using {nS_shortened} segments\")",
      "                            print(f\"    and adding wire from {wo[\"b\"]} to {b_orig}:  {length_remainder}m using {nS_remainder} segments\")",
      "                        break #(for efficiency only)",
      "        for params in wires_to_add:",
      "            other._add_wire(*params)",
      "",
      "#===============================================================",
      "# internal functions for class GeometryObject",
      "#==============================================================="
    ]
  },
  {
    "type": "def",
    "line_number": 473,
    "signature": "_cos_sin(self,angle_deg)",
    "indent_level": 1,
    "docstring": [],
    "body": [
      "        angle_rad = math.pi*angle_deg/180",
      "        ca = math.cos(angle_rad)",
      "        sa = math.sin(angle_rad)",
      "        return ca, sa"
    ]
  },
  {
    "type": "def",
    "line_number": 479,
    "signature": "_rotate(self, R)",
    "indent_level": 1,
    "docstring": [],
    "body": [
      "        for w in self.wires:",
      "            a = np.array(w['a'])",
      "            b = np.array(w['b'])",
      "            w['a'] = tuple(map(float, R @ a))",
      "            w['b'] = tuple(map(float, R @ b))"
    ]
  },
  {
    "type": "def",
    "line_number": 486,
    "signature": "_add_wire(self, iTag, nS, x1, y1, z1, x2, y2, z2, wr)",
    "indent_level": 1,
    "docstring": [],
    "body": [
      "        self.wires.append({\"iTag\":iTag, \"nS\":nS, \"a\":(x1, y1, z1), \"b\":(x2, y2, z2), \"wr\":wr})"
    ]
  },
  {
    "type": "def",
    "line_number": 489,
    "signature": "_get_wires(self)",
    "indent_level": 1,
    "docstring": [],
    "body": [
      "        return self.wires"
    ]
  },
  {
    "type": "def",
    "line_number": 492,
    "signature": "_point_should_connect_to_wire(self,P, wire, tol=1e-3)",
    "indent_level": 1,
    "docstring": [],
    "body": [
      "        P = np.array(P, dtype=float)",
      "        A = np.array(wire['a'], dtype=float)",
      "        B = np.array(wire['b'], dtype=float)",
      "        AB = B - A",
      "        AP = P - A",
      "        AB_len = np.linalg.norm(AB)",
      "        # can't connect to a zero length wire using the splitting method",
      "        if AB_len == 0:",
      "            return False",
      "        ",
      "        # Check perpendicular distance from wire axis",
      "        # if we aren't close enough to the wire axis to need to connect, return false",
      "        # NOTE: need to align tol with nec's check of volumes intersecting",
      "        perp_dist = np.linalg.norm(np.cross(AP, AB)) / AB_len",
      "        if perp_dist > tol: ",
      "            return False    ",
      "",
      "        # Project point onto the wire to get fractional position",
      "        alpha = np.dot(AP, AB) / (AB_len**2)",
      "        if not (0 <= alpha <= 1):",
      "            return False  # point is on the wire axis but not between the wire ends",
      "",
      "        # If we are within allowable tolerance of the wire ends, don't split the wire",
      "        dist_from_end = min(alpha*AB_len, (1-alpha)*AB_len)",
      "        if (dist_from_end < tol):",
      "            return False",
      "",
      "        # IF the wire is already segmented (e.g. in a grid), check how far from the",
      "        # *nearest* segment boundary this projected alpha is",
      "        if(wire['nS']>0):",
      "            segment_pitch = 1 / wire['nS']",
      "            nearest_alpha = round(alpha / segment_pitch) * segment_pitch",
      "            alpha_dist = abs(alpha - nearest_alpha)",
      "            alpha_tol = tol / AB_len  # convert spatial tol to alpha-space",
      "            if alpha_dist < alpha_tol:",
      "                return False  # near a segment end \u00e2\u20ac\u201d NEC will handle this as a normal junction",
      "",
      "        return True  # wire needs to be split to allow the connection"
    ]
  },
  {
    "type": "def",
    "line_number": 532,
    "signature": "_point_on_object(self,geom_object, wire_index, alpha_wire)",
    "indent_level": 1,
    "docstring": [],
    "body": [
      "        if(wire_index> len(geom_object.wires)):",
      "            wire_index = len(geom_object.wires)",
      "            alpha_wire = 1.0",
      "        w = geom_object.wires[wire_index]",
      "        A = np.array(w[\"a\"], dtype=float)",
      "        B = np.array(w[\"b\"], dtype=float)",
      "        P = A + alpha_wire * (B-A)",
      "        return P",
      "         ",
      "#=================================================================================",
      "# Units processor",
      "#================================================================================="
    ]
  },
  {
    "type": "class",
    "line_number": 546,
    "signature": "_units:",
    "indent_level": 0,
    "docstring": [],
    "body": []
  },
  {
    "type": "def",
    "line_number": 548,
    "signature": "_from_suffixed_dimensions(self, params: dict, whitelist=[])",
    "indent_level": 1,
    "docstring": [
      "        \"\"\"Converts suffixed values like 'd_mm' to meters.",
      "",
      "        Output keys have '_m' suffix unless they already end with '_m',",
      "        in which case they are passed through unchanged (assumed meters).",
      "        \"\"\""
    ],
    "body": [
      "",
      "        _UNIT_FACTORS = {",
      "        \"m\": 1.0,",
      "        \"mm\": 1000.0,",
      "        \"cm\": 100.0,",
      "        \"in\": 39.3701,",
      "        \"ft\": 3.28084,",
      "        }",
      "",
      "        out = {}",
      "        names_seen = []",
      "        for key, value in params.items():",
      "    ",
      "            if not isinstance(value, (int, float)):",
      "                continue  # skip nested dicts or other structures",
      "",
      "            name = key",
      "            suffix = \"\"",
      "            if \"_\" in name:",
      "                name, suffix = name.rsplit(\"_\", 1)",
      "                ",
      "            if(name in names_seen):",
      "                warnstr = f\"Duplicate value of '{name}' seen: ignoring latest ({key} = {value})\"",
      "                warnings.warn(warnstr)",
      "                continue",
      "",
      "            names_seen.append(name)",
      "",
      "            if suffix in _UNIT_FACTORS:",
      "                # Convert value, output key with '_m' suffix",
      "                out[name + \"_m\"] = value / _UNIT_FACTORS[suffix]",
      "                continue",
      "",
      "            if key in whitelist:",
      "                continue",
      "            ",
      "            # fallback: no recognised suffix, assume metres",
      "            warnings.warn(f\"No recognised units specified for {name}: '{suffix}' specified, metres assumed\")",
      "            # output key gets '_m' suffix added",
      "            out[name + \"_m\"] = value",
      "",
      "        return out",
      "",
      ""
    ]
  }
]